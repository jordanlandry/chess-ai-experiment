use std::collections::HashMap;

use crate::print_bitboard;


#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Bitboard {
    pub white_pawns: u64,
    pub white_knights: u64,
    pub white_bishops: u64,
    pub white_rooks: u64,
    pub white_queens: u64,
    pub white_king: u64,

    pub black_pawns: u64,
    pub black_knights: u64,
    pub black_bishops: u64,
    pub black_rooks: u64,
    pub black_queens: u64,
    pub black_king: u64,
}



// I got these values by running a python script that creates the bitboard for each file and rank
// Then converts it to a u64 and prints it out as a rust constant (see below)
// See: from the base directory: './python_helpers/get_rank_file_val.py'

// Files
pub const FILE_A: u64 = 72340172838076673;
pub const FILE_B: u64 = 144680345676153346;
pub const FILE_C: u64 = 289360691352306692;
pub const FILE_D: u64 = 578721382704613384;
pub const FILE_E: u64 = 1157442765409226768;
pub const FILE_F: u64 = 2314885530818453536;
pub const FILE_G: u64 = 4629771061636907072;
pub const FILE_H: u64 = 9259542123273814144;

// Ranks
pub const RANK_1: u64 = 255;
pub const RANK_2: u64 = 65280;
pub const RANK_3: u64 = 16711680;
pub const RANK_4: u64 = 4278190080;
pub const RANK_5: u64 = 1095216660480;
pub const RANK_6: u64 = 280375465082880;
pub const RANK_7: u64 = 71776119061217280;
pub const RANK_8: u64 = 18374686479671623680;


// Generate all rook attacks for each square to use as a lookup table instead of calculating them each time

// The way I'm going to index them, is by getting all of the relevant bits for each square, then indexing into a hashmap
// with the key being the relevant bits and the value being the attack bitboard
// fn get_relevant_bits(board: Bitboard, square: usize) -> u64 {
//     let mut relevant_bits: u64 = 0;
// }

// These values were generated by running a python script
// See: (from root directory) './python_helpers/get_relevant_bits.py'
pub const ROOK_RELEVANT_BITS: [u64; 64] = [0b0000000100000001000000010000000100000001000000010000000111111110, 0b0000001000000010000000100000001000000010000000100000001011111101, 0b0000010000000100000001000000010000000100000001000000010011111011, 0b0000100000001000000010000000100000001000000010000000100011110111, 0b0001000000010000000100000001000000010000000100000001000011101111, 0b0010000000100000001000000010000000100000001000000010000011011111, 0b0100000001000000010000000100000001000000010000000100000010111111, 0b1000000010000000100000001000000010000000100000001000000001111111, 0b0000000100000001000000010000000100000001000000011111111000000001, 0b0000001000000010000000100000001000000010000000101111110100000010, 0b0000010000000100000001000000010000000100000001001111101100000100, 0b0000100000001000000010000000100000001000000010001111011100001000, 0b0001000000010000000100000001000000010000000100001110111100010000, 0b0010000000100000001000000010000000100000001000001101111100100000, 0b0100000001000000010000000100000001000000010000001011111101000000, 0b1000000010000000100000001000000010000000100000000111111110000000, 0b0000000100000001000000010000000100000001111111100000000100000001, 0b0000001000000010000000100000001000000010111111010000001000000010, 0b0000010000000100000001000000010000000100111110110000010000000100, 0b0000100000001000000010000000100000001000111101110000100000001000, 0b0001000000010000000100000001000000010000111011110001000000010000, 0b0010000000100000001000000010000000100000110111110010000000100000, 0b0100000001000000010000000100000001000000101111110100000001000000, 0b1000000010000000100000001000000010000000011111111000000010000000, 0b0000000100000001000000010000000111111110000000010000000100000001, 0b0000001000000010000000100000001011111101000000100000001000000010, 0b0000010000000100000001000000010011111011000001000000010000000100, 0b0000100000001000000010000000100011110111000010000000100000001000, 0b0001000000010000000100000001000011101111000100000001000000010000, 0b0010000000100000001000000010000011011111001000000010000000100000, 0b0100000001000000010000000100000010111111010000000100000001000000, 0b1000000010000000100000001000000001111111100000001000000010000000, 0b0000000100000001000000011111111000000001000000010000000100000001, 0b0000001000000010000000101111110100000010000000100000001000000010, 0b0000010000000100000001001111101100000100000001000000010000000100, 0b0000100000001000000010001111011100001000000010000000100000001000, 0b0001000000010000000100001110111100010000000100000001000000010000, 0b0010000000100000001000001101111100100000001000000010000000100000, 0b0100000001000000010000001011111101000000010000000100000001000000, 0b1000000010000000100000000111111110000000100000001000000010000000, 0b0000000100000001111111100000000100000001000000010000000100000001, 0b0000001000000010111111010000001000000010000000100000001000000010, 0b0000010000000100111110110000010000000100000001000000010000000100, 0b0000100000001000111101110000100000001000000010000000100000001000, 0b0001000000010000111011110001000000010000000100000001000000010000, 0b0010000000100000110111110010000000100000001000000010000000100000, 0b0100000001000000101111110100000001000000010000000100000001000000, 0b1000000010000000011111111000000010000000100000001000000010000000, 0b0000000111111110000000010000000100000001000000010000000100000001, 0b0000001011111101000000100000001000000010000000100000001000000010, 0b0000010011111011000001000000010000000100000001000000010000000100, 0b0000100011110111000010000000100000001000000010000000100000001000, 0b0001000011101111000100000001000000010000000100000001000000010000, 0b0010000011011111001000000010000000100000001000000010000000100000, 0b0100000010111111010000000100000001000000010000000100000001000000, 0b1000000001111111100000001000000010000000100000001000000010000000, 0b1111111000000001000000010000000100000001000000010000000100000001, 0b1111110100000010000000100000001000000010000000100000001000000010, 0b1111101100000100000001000000010000000100000001000000010000000100, 0b1111011100001000000010000000100000001000000010000000100000001000, 0b1110111100010000000100000001000000010000000100000001000000010000, 0b1101111100100000001000000010000000100000001000000010000000100000, 0b1011111101000000010000000100000001000000010000000100000001000000, 0b0111111110000000100000001000000010000000100000001000000010000000];


#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MoveHashKey {
    pub relevant_bits: u64,
    pub relevant_occupancy: u64,
}

static mut ROOK_MOVES: Option<HashMap<MoveHashKey, u64>> = None;

fn get_relevant_occupancy(square: u8, occupancy: u64) -> u64 {
    let mut relevant_occupancy: u64 = 0;

    // We can get the relevant bits, and then use the occupancy to get the relevant occupancy
    let relevant_bits = ROOK_RELEVANT_BITS[square as usize];

    // Using the occupancy, we can cut off pieces that extend past an occupied square
    // Example 

    // Let's say these are the relevant bits
    // 1 1 1 0 1 1 1 1

    // If we have an occupancy of
    // 0 0 0 0 1 1 1 1

    // Then the relevant occupancy is
    //  0 0 0 0 1 0 0 0 

    // This is because it doesn't matter if the pieces to the right of it are occupied, as the piece will be blocked by the first piece

    // Remove all bits left of the first 1 in the same row
    let mut i = square;
    while i % 8 != 0 {
        i -= 1;
        if (relevant_bits & (1 << i)) != 0 {
            break;
        }

        relevant_occupancy |= 1 << i;
    }

    // Remove all bits right of the last 1 in the same row
    i = square;
    while i % 8 != 7 {
        i += 1;
        if (relevant_bits & (1 << i)) != 0 {
            break;
        }

        relevant_occupancy |= 1 << i;
    }

    // Remove all bits above the first 1 in the same column
    i = square;
    while i / 8 != 0 {
        i -= 8;
        if (relevant_bits & (1 << i)) != 0 {
            break;
        }

        relevant_occupancy |= 1 << i;
    }

    // Remove all bits below the last 1 in the same column
    i = square;
    while i / 8 != 7 {
        i += 8;
        if (relevant_bits & (1 << i)) != 0 {
            break;
        }

        relevant_occupancy |= 1 << i;
    }

    relevant_occupancy
}

pub fn init_rook_moves() {
    let moves = generate_rook_moves();
    unsafe {
        ROOK_MOVES = Some(moves);
    }
}

// Calculate the available rook moves from the generate function
pub fn calculate_rook_moves(square: usize, occupancy: u64) -> u64 {
    let mut moves: u64 = 0;

    let mut i = square;
    while i % 8 != 0 {
        i -= 1;
        if (occupancy & (1 << i)) != 0 {
            break;
        }

        moves |= 1 << i;
    }

    i = square;
    while i % 8 != 7 {
        i += 1;
        if (occupancy & (1 << i)) != 0 {
            break;
        }

        moves |= 1 << i;
    }

    i = square;
    while i / 8 != 0 {
        i -= 8;
        if (occupancy & (1 << i)) != 0 {
            break;
        }

        moves |= 1 << i;
    }

    i = square;
    while i / 8 != 7 {
        i += 8;
        if (occupancy & (1 << i)) != 0 {
            break;
        }

        moves |= 1 << i;
    }

    moves
}

pub fn generate_rook_moves() -> HashMap<MoveHashKey, u64> {
    let mut rook_moves: HashMap<MoveHashKey, u64> = HashMap::new();
    
    // for i in 0..64 {
    //     let mut relevant_occupancy: u64 = 0;

    //     // We can get the relevant bits, and then use the occupancy to get the relevant occupancy
    //     let relevant_bits = ROOK_RELEVANT_BITS[i];
        

    //     let key = MoveHashKey {
    //         relevant_bits: ROOK_RELEVANT_BITS[i],
    //         relevant_occupancy,
    //     };

    //     rook_moves.insert(key, moves);
    // }

    rook_moves
}


pub fn rook_moves(occupancy: u64, square: u8) -> u64 {
    let mut moves: u64 = 0;

    let relevant_occupancy = get_relevant_occupancy(square, occupancy);

    let key = MoveHashKey {
        relevant_bits: ROOK_RELEVANT_BITS[square as usize],
        relevant_occupancy,
    };

    unsafe {
        if let Some(rook_moves) = &ROOK_MOVES {
            if let Some(m) = rook_moves.get(&key) {
                moves = *m;
            }
        }
    }

    moves
}