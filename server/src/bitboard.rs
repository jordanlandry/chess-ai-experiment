use std::collections::HashMap;

use crate::print_bitboard;


#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Bitboard {
    pub white_pawns: u64,
    pub white_knights: u64,
    pub white_bishops: u64,
    pub white_rooks: u64,
    pub white_queens: u64,
    pub white_king: u64,

    pub black_pawns: u64,
    pub black_knights: u64,
    pub black_bishops: u64,
    pub black_rooks: u64,
    pub black_queens: u64,
    pub black_king: u64,
}



// I got these values by running a python script that creates the bitboard for each file and rank
// Then converts it to a u64 and prints it out as a rust constant (see below)
// See: from the base directory: './python_helpers/get_rank_file_val.py'

// Files
pub const FILE_A: u64 = 72340172838076673;
pub const FILE_B: u64 = 144680345676153346;
pub const FILE_C: u64 = 289360691352306692;
pub const FILE_D: u64 = 578721382704613384;
pub const FILE_E: u64 = 1157442765409226768;
pub const FILE_F: u64 = 2314885530818453536;
pub const FILE_G: u64 = 4629771061636907072;
pub const FILE_H: u64 = 9259542123273814144;

// Ranks
pub const RANK_1: u64 = 255;
pub const RANK_2: u64 = 65280;
pub const RANK_3: u64 = 16711680;
pub const RANK_4: u64 = 4278190080;
pub const RANK_5: u64 = 1095216660480;
pub const RANK_6: u64 = 280375465082880;
pub const RANK_7: u64 = 71776119061217280;
pub const RANK_8: u64 = 18374686479671623680;


// Generate all rook attacks for each square to use as a lookup table instead of calculating them each time

// The way I'm going to index them, is by getting all of the relevant bits for each square, then indexing into a hashmap
// with the key being the relevant bits and the value being the attack bitboard
// fn get_relevant_bits(board: Bitboard, square: usize) -> u64 {
//     let mut relevant_bits: u64 = 0;
// }

// These values were generated by running a python script
// See: (from root directory) './python_helpers/get_relevant_bits.py'
pub const ROOK_RELEVANT_BITS: [u64; 64] = [0b0000000100000001000000010000000100000001000000010000000111111110, 0b0000001000000010000000100000001000000010000000100000001011111101, 0b0000010000000100000001000000010000000100000001000000010011111011, 0b0000100000001000000010000000100000001000000010000000100011110111, 0b0001000000010000000100000001000000010000000100000001000011101111, 0b0010000000100000001000000010000000100000001000000010000011011111, 0b0100000001000000010000000100000001000000010000000100000010111111, 0b1000000010000000100000001000000010000000100000001000000001111111, 0b0000000100000001000000010000000100000001000000011111111000000001, 0b0000001000000010000000100000001000000010000000101111110100000010, 0b0000010000000100000001000000010000000100000001001111101100000100, 0b0000100000001000000010000000100000001000000010001111011100001000, 0b0001000000010000000100000001000000010000000100001110111100010000, 0b0010000000100000001000000010000000100000001000001101111100100000, 0b0100000001000000010000000100000001000000010000001011111101000000, 0b1000000010000000100000001000000010000000100000000111111110000000, 0b0000000100000001000000010000000100000001111111100000000100000001, 0b0000001000000010000000100000001000000010111111010000001000000010, 0b0000010000000100000001000000010000000100111110110000010000000100, 0b0000100000001000000010000000100000001000111101110000100000001000, 0b0001000000010000000100000001000000010000111011110001000000010000, 0b0010000000100000001000000010000000100000110111110010000000100000, 0b0100000001000000010000000100000001000000101111110100000001000000, 0b1000000010000000100000001000000010000000011111111000000010000000, 0b0000000100000001000000010000000111111110000000010000000100000001, 0b0000001000000010000000100000001011111101000000100000001000000010, 0b0000010000000100000001000000010011111011000001000000010000000100, 0b0000100000001000000010000000100011110111000010000000100000001000, 0b0001000000010000000100000001000011101111000100000001000000010000, 0b0010000000100000001000000010000011011111001000000010000000100000, 0b0100000001000000010000000100000010111111010000000100000001000000, 0b1000000010000000100000001000000001111111100000001000000010000000, 0b0000000100000001000000011111111000000001000000010000000100000001, 0b0000001000000010000000101111110100000010000000100000001000000010, 0b0000010000000100000001001111101100000100000001000000010000000100, 0b0000100000001000000010001111011100001000000010000000100000001000, 0b0001000000010000000100001110111100010000000100000001000000010000, 0b0010000000100000001000001101111100100000001000000010000000100000, 0b0100000001000000010000001011111101000000010000000100000001000000, 0b1000000010000000100000000111111110000000100000001000000010000000, 0b0000000100000001111111100000000100000001000000010000000100000001, 0b0000001000000010111111010000001000000010000000100000001000000010, 0b0000010000000100111110110000010000000100000001000000010000000100, 0b0000100000001000111101110000100000001000000010000000100000001000, 0b0001000000010000111011110001000000010000000100000001000000010000, 0b0010000000100000110111110010000000100000001000000010000000100000, 0b0100000001000000101111110100000001000000010000000100000001000000, 0b1000000010000000011111111000000010000000100000001000000010000000, 0b0000000111111110000000010000000100000001000000010000000100000001, 0b0000001011111101000000100000001000000010000000100000001000000010, 0b0000010011111011000001000000010000000100000001000000010000000100, 0b0000100011110111000010000000100000001000000010000000100000001000, 0b0001000011101111000100000001000000010000000100000001000000010000, 0b0010000011011111001000000010000000100000001000000010000000100000, 0b0100000010111111010000000100000001000000010000000100000001000000, 0b1000000001111111100000001000000010000000100000001000000010000000, 0b1111111000000001000000010000000100000001000000010000000100000001, 0b1111110100000010000000100000001000000010000000100000001000000010, 0b1111101100000100000001000000010000000100000001000000010000000100, 0b1111011100001000000010000000100000001000000010000000100000001000, 0b1110111100010000000100000001000000010000000100000001000000010000, 0b1101111100100000001000000010000000100000001000000010000000100000, 0b1011111101000000010000000100000001000000010000000100000001000000, 0b0111111110000000100000001000000010000000100000001000000010000000];

pub fn test() {
    print_bitboard(ROOK_RELEVANT_BITS[1]);
}


#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct MoveHashKey {
    pub relevant_bits: u64,
    pub relevant_occupancy: u64,
}

static mut ROOK_MOVES: Option<HashMap<MoveHashKey, u64>> = None;

fn get_relevant_occupancy(square: u8, occupancy: u64) -> u64 {
    let mut relevant_occupancy: u64 = 0;

    // We can get the relevant bits, and then use the occupancy to get the relevant occupancy
    let relevant_bits = ROOK_RELEVANT_BITS[square as usize];

    // Using the occupancy, we can cut off pieces that extend past an occupied square
    // Example 

    // Let's say these are the relevant bits
    // 1 1 1 0 1 1 1 1

    // If we have an occupancy of
    // 0 0 0 0 1 1 1 1

    // Then the relevant occupancy is
    //  0 0 0 0 1 0 0 0 

    // This is because it doesn't matter if the pieces to the right of it are occupied, as the piece will be blocked by the first piece


    // i: rook position
    // j: horizontal relevant bit
    // k: vertical relevant bit
    for i in 0..64 {
        for j in 0..8 {
            for k in 0..8 {
                let relevant_occupancy_mask = 1 << (i * 64 + j * 8 + k);

                print_bitboard(relevant_occupancy);

                return 0;
            }
        }
    }

    // for i in 0..8 {
    //     let mask = 1 << i;
    //     let bit_is_set = (relevant_bits & mask) != 0;
    //     if bit_is_set {
    //         let mut current_square = square as i8;
    //         let mut current_file = current_square % 8;
    //         let mut current_rank = current_square / 8;
    //         let mut finished_rank = false;
    //         let mut finished_file = false;
    
    //         while !finished_rank || !finished_file {
    //             if !finished_rank {
    //                 current_rank += i8::from(if i < 4 { 1 } else { -1 });
    //                 if current_rank > 7 || current_rank < 0 {
    //                     finished_rank = true;
    //                 }
    //             }
            
    //             if !finished_file {
    //                 current_file += i8::from(if i % 4 < 2 { 1 } else { -1 });
    //                 if current_file > 7 || current_file < 0 {
    //                     finished_file = true;
    //                 }
    //             }
            
    //             if !finished_rank || !finished_file {
    //                 current_square = current_rank * 8 + current_file;

    //                 if current_square < 0 || current_square > 63 {
    //                     break;
    //                 }

    //                 let mask = 1u64 << current_square;
    //                 if (mask & occupancy) != 0 {
    //                     finished_rank = true;
    //                     finished_file = true;
    //                 } else {
    //                     relevant_occupancy |= mask;
    //                 }
    //             }
    //         }
    //     }
    // }

    relevant_occupancy
}

pub fn init_rook_moves() {
    let moves = generate_rook_moves();
    unsafe {
        ROOK_MOVES = Some(moves);
    }
}


pub fn generate_rook_moves() -> HashMap<MoveHashKey, u64> {
    let mut rook_moves: HashMap<MoveHashKey, u64> = HashMap::new();

    for rook_position in 0..64 {
        // let left_bit_start = rook_position % 8 + ;

        let x = rook_position % 8;
        let y = rook_position / 8;

        let left_bit_start = y * 8;
        let right_bit_start = y * 8 + 7;

        for left_bit in left_bit_start..rook_position {
            // TODO
        }
    }

    rook_moves
}


pub fn rook_moves(occupancy: u64, square: u8) -> u64 {
    let mut moves: u64 = 0;

    let relevant_occupancy = get_relevant_occupancy(square, occupancy);

    let key = MoveHashKey {
        relevant_bits: ROOK_RELEVANT_BITS[square as usize],
        relevant_occupancy,
    };

    unsafe {
        if let Some(rook_moves) = &ROOK_MOVES {
            if let Some(m) = rook_moves.get(&key) {
                moves = *m;
            }
        }
    }

    moves
}